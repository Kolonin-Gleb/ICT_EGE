# Тип 5 Алгоритмы для Исполнителей

# Task 1
'''
for N in range(1_000):
    N = bin(N)
    ost = N.count("1") % 2
    N = N + str(ost)

    ost = N.count("1") % 2
    N = N + str(ost)

    # является двоичной записью искомого числа R
    R = int(N, base=0)
    if R > 180:
        print(R)
        break
    # 184 -- correct
'''

# Task 2
'''
for N in range(1_000):
    # N_last = bin(N % 10) # Последняя цифра (ОТ 2ого или 10ого числа??)
    # bin_N = bin(N) + N_last[2:]

    bin_N = bin(N) + bin(N)[-1]

    # Затем справа дописывается бит чётности:
    # 0, если в двоичном коде полученного числа чётное число единиц, и 1, если нечётное.
    if bin_N.count('1') % 2 == 0:
        bin_N += '0'
    else:
        bin_N += '1'
    # К полученному результату дописывается ещё один бит чётности.
    if bin_N.count('1') % 2 == 0:
        bin_N += '0'
    else:
        bin_N += '1'
    # в Получившемся N на три разряда больше, чем в записи исходного числа N
    R = int(bin_N, base=0)
    if R > 114:
        print(N)
        break
'''

# Task 3
'''
for N in range(1_000):
    if N % 2 == 0:
        bin_N = bin(N) + '10'
    else:
        bin_N = '0b' + '1' + bin(N)[2:] + '01'
    
    R = int(bin_N, base=0)
    if R > 516:
        print(N) # 65
        break
'''

# Task 4
'''
for N in range(1_000):
    # если N чётное, то к нему слева дописывается 10, а справа - 1,
    # если N нечетное – слева дописывается 1 и справа 01;
    if N % 2 == 0:
        bin_N = '0b' + '10' + bin(N)[2:] + '1'
    else:
        bin_N = '0b' + '1' + bin(N)[2:] + '01'
    R = int(bin_N, 0)
    if R > 420:
        print(N)
        break
'''

# Task 5
'''
а) если сумма цифр в двоичной записи числа чётная,
то к этой записи справа дописывается 0, а затем два левых разряда заменяются на 10;
б) если сумма цифр в двоичной записи числа нечётная,
то к этой записи справа дописывается 1, а затем два левых разряда заменяются на 11.
3) Результат переводится в десятичную систему и выводится на экран.
Укажите максимальное число N, после обработки которого с помощью этого алгоритма получается число R, меньшее, чем 35.

for N in range(1_000):
    bin_N = bin(N)
    if bin_N.count('1') % 2 == 0:
        # справа дописывается 0, а затем два левых разряда заменяются на 10;
        bin_N = '0b' + '10' + bin_N[4:] + '0'
    else:
        # справа дописывается 1, а затем два левых разряда заменяются на 11.
        bin_N = '0b' + '11' + bin_N[4:] + '1'

    R = int(bin_N, 0)
    if R < 35:
        print(N)
'''

# LAST TASK
'''
a = []
for N in range(4,100): #берем с 4, так как числа меньше не дадут нам 3-ех цифр в двоичной системе
    if N % 3 == 0:
        bin_N = bin(N)[2:] + bin(N)[-3:]
        #print(N,bin(N)[2:],bin_N) #выводим числа для отладки. Проверяем правильно ли работает алгоритм
    else:
        ost = (N % 3) * 3
        bin_N = bin(N)[2:] + bin(ost)[2:]
        #print(N, bin(N)[2:], bin_N)

    R = int(bin_N, 2)
    if R > 151:
        a.append(R)
print(min(a)) # 163
'''
